---
phase: 10-taste-map-infrastructure
plan: "03"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/watchlist/route.ts
autonomous: true
gap_closure: true
requirements: []

must_haves:
  truths:
    - "Background recomputation triggered via Next.js after() without blocking response"
    - "User's taste map updates when they change status or rating"
    - "API response returns immediately without waiting for taste map computation"
  artifacts:
    - path: "src/app/api/watchlist/route.ts"
      provides: "Watchlist CRUD with taste map invalidation"
      contains: "after("
    - path: "src/lib/taste-map/compute.ts"
      provides: "recomputeTasteMap function"
      exports: ["recomputeTasteMap"]
  key_links:
    - from: "src/app/api/watchlist/route.ts"
      to: "src/lib/taste-map/compute.ts"
      via: "import recomputeTasteMap"
      pattern: "import.*recomputeTasteMap"
    - from: "src/app/api/watchlist/route.ts"
      to: "next/server"
      via: "import after"
      pattern: "import.*after.*from.*next/server"
---

<objective>
Integrate Next.js `after()` to trigger background taste map recomputation when user changes status or rating.

Purpose: Ensure taste map stays fresh without blocking API responses. Users get instant feedback when updating watchlist, while their preference profile updates asynchronously.

Output: Modified `/api/watchlist/route.ts` with non-blocking taste map recomputation.
</objective>

<execution_context>
@C:/Users/n0rds/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/n0rds/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing implementation (from 10-01 and 10-02)
@src/lib/taste-map/compute.ts
@src/app/api/watchlist/route.ts

# RESEARCH.md Pattern 5 (background update pattern)
```typescript
import { after } from 'next/server';

export async function PATCH(req: Request) {
  // ... main logic (update status/rating)
  
  const userId = session.user.id;
  
  // Trigger async taste-map recomputation
  after(async () => {
    try {
      await recomputeTasteMap(userId);
    } catch (error) {
      logger.error('Taste map recompute failed', { 
        error: error instanceof Error ? error.message : String(error),
        userId 
      });
    }
  });
  
  return NextResponse.json({ success: true });
}
```
</context>

<tasks>

<task type="auto">
  <name>Integrate after() for background taste map recomputation</name>
  <files>src/app/api/watchlist/route.ts</files>
  <action>
Modify the watchlist API route to trigger background taste map recomputation using Next.js `after()`.

**Changes required:**

1. **Add imports at top of file:**
   ```typescript
   import { after } from 'next/server';
   import { recomputeTasteMap } from '@/lib/taste-map/compute';
   ```

2. **Add after() call in POST handler** - After successful response, before `return NextResponse.json(...)`:
   - After the `isRatingOnly` block success return (line ~221): Wrap the return in a block and add after() before it
   - After the `isRewatch` block success return (line ~332): Wrap the return in a block and add after() before it
   - After the main status update success (line ~467): Add after() before `return NextResponse.json({ success: true, record })`

3. **Add after() call in DELETE handler** - After successful deletion (line ~510): Add after() before the return

**Pattern for each integration point:**
```typescript
// Trigger background taste map recomputation
after(async () => {
  try {
    await recomputeTasteMap(session.user.id);
  } catch (error) {
    logger.error('Taste map recompute failed', {
      error: error instanceof Error ? error.message : String(error),
      userId: session.user.id,
    });
  }
});

return NextResponse.json({ success: true });
```

**Why after() instead of await:** The taste map computation involves TMDB API calls and can take several seconds. Using `after()` ensures the user gets an instant response while their profile updates in the background.

**Do NOT change:** Any existing logic - only add the import and after() calls before returns.
  </action>
  <verify>
    ```bash
    # Verify imports are present
    grep -n "import { after }" src/app/api/watchlist/route.ts
    grep -n "import.*recomputeTasteMap" src/app/api/watchlist/route.ts
    
    # Verify after() is called in POST (should appear multiple times)
    grep -c "after(async () =>" src/app/api/watchlist/route.ts
    
    # Run lint and tests
    npm run lint && npm run test:ci
    ```
  </verify>
  <done>
    - `after` imported from `next/server`
    - `recomputeTasteMap` imported from `@/lib/taste-map/compute`
    - `after()` calls present in POST handler (all success paths)
    - `after()` call present in DELETE handler
    - All lint and tests pass
  </done>
</task>

</tasks>

<verification>
- [ ] `after` imported from `next/server`
- [ ] `recomputeTasteMap` imported from `@/lib/taste-map/compute`
- [ ] POST handler triggers background recomputation on status change
- [ ] POST handler triggers background recomputation on rating change
- [ ] POST handler triggers background recomputation on rewatch
- [ ] DELETE handler triggers background recomputation on removal
- [ ] `npm run lint` passes
- [ ] `npm run test:ci` passes
</verification>

<success_criteria>
Background recomputation is triggered via Next.js `after()` without blocking the API response. User status/rating changes immediately return success while taste map updates asynchronously.
</success_criteria>

<output>
After completion, create `.planning/phases/10-taste-map-infrastructure/10-03-SUMMARY.md`
</output>
