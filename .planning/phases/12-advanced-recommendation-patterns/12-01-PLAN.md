---
phase: 12-advanced-recommendation-patterns
plan: '01'
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/recommendation-algorithms.ts
  - src/lib/recommendation-algorithms/genre-twins.ts
  - src/lib/recommendation-algorithms/genre-recommendations.ts
autonomous: true
requirements:
  - REC-05
  - REC-06

must_haves:
  truths:
    - User can receive recommendations based on users with similar genre preferences
    - User can see highly-rated movies from their dominant genres
    - Recommendations avoid recently shown items (7-day cooldown)
    - Cold start users with <10 watched movies receive fallback recommendations
  artifacts:
    - path: src/lib/recommendation-algorithms/genre-twins.ts
      provides: Genre Twins algorithm (Pattern 5)
      min_lines: 300
      exports: genreTwins as IRecommendationAlgorithm
    - path: src/lib/recommendation-algorithms/genre-recommendations.ts
      provides: Genre Recommendations algorithm (Pattern 6)
      min_lines: 300
      exports: genreRecommendations as IRecommendationAlgorithm
    - path: src/lib/recommendation-algorithms.ts
      provides: Algorithm exports updated
      contains: genreTwins, genreRecommendations
  key_links:
    - from: src/lib/recommendation-algorithms/genre-twins.ts
      to: src/lib/taste-map/similarity.ts
      via: cosineSimilarity function
      pattern: cosineSimilarity.*genreProfile
    - from: src/lib/recommendation-algorithms/genre-recommendations.ts
      to: src/lib/taste-map/redis.ts
      via: getGenreProfile function
      pattern: getGenreProfile.*dominantGenres
---

<objective>
Implement Patterns 5-6: Genre Twins and Genre Recommendations

Purpose: Add genre-based collaborative filtering to complement existing user similarity patterns. Genre Twins finds users with similar genre preferences, while Genre Recommendations uses user's dominant genres to find highly-rated content in those genres.

Output: Two new recommendation algorithms exported from recommendation-algorithms.ts
</objective>

<context>
@src/lib/recommendation-algorithms/interface.ts
@src/lib/recommendation-algorithms/types.ts
@src/lib/taste-map/types.ts
@src/lib/taste-map/similarity.ts (cosineSimilarity function)
@src/lib/taste-map/redis.ts (getGenreProfile)

Reference Phase 11 patterns for architecture:
@src/lib/recommendation-algorithms/taste-match.ts
@src/lib/recommendation-algorithms/type-twins.ts
</context>

<tasks>

<task type="auto">
  <name>Create Genre Twins algorithm (Pattern 5)</name>
  <files>src/lib/recommendation-algorithms/genre-twins.ts</files>
  <action>
Create src/lib/recommendation-algorithms/genre-twins.ts implementing IRecommendationAlgorithm:

1. Algorithm name: 'genre_twins_v1', minUserHistory: 10
2. Use getGenreProfile() from taste-map/redis.ts to get user's genre profile
3. Use cosineSimilarity() from taste-map/similarity.ts to find users with similar genre profiles
4. Similarity threshold: 0.6, max 15 similar users
5. Candidate pool: fetch top-rated watched movies (rating >= 7) from genre-similar users
6. Score formula: (genreSimilarity * 0.5) + (rating * 0.3) + (cooccurrence * 0.2)
7. Apply cooldown filter (7 days via RecommendationLog)
8. Exclude user's existing watchlist items
9. Use normalizeScores() for 0-100 scale
10. Cold start fallback: return empty recommendations (handled by orchestration)
11. Log metrics: candidatesPoolSize, afterFilters, avgScore
  </action>
  <verify>
File created with exports matching IRecommendationAlgorithm interface
Passes TypeScript compilation: npx tsc --noEmit
Follows pattern structure from taste-match.ts
  </verify>
  <done>
Genre Twins algorithm implemented: finds users with similar genre preferences and recommends their highly-rated watched movies
</done>
</task>

<task type="auto">
  <name>Create Genre Recommendations algorithm (Pattern 6)</name>
  <files>src/lib/recommendation-algorithms/genre-recommendations.ts</files>
  <action>
Create src/lib/recommendation-algorithms/genre-recommendations.ts implementing IRecommendationAlgorithm:

1. Algorithm name: 'genre_recommendations_v1', minUserHistory: 5
2. Get user's genre profile via getGenreProfile()
3. Extract dominant genres (top 3 genres with score >= 50)
4. Find similar users via getSimilarUsers() from taste-map/similarity.ts
5. For each similar user, fetch their watched movies in user's dominant genres
6. Candidate pool: movies that match user's dominant genres
7. Score formula: (genreMatchScore * 0.4) + (rating * 0.4) + (userSimilarity * 0.2)
8. Apply cooldown filter and exclude existing watchlist
9. Use normalizeScores() for 0-100 scale
10. Cold start fallback: return empty (orchestration handles popularity fallback)
11. Log metrics and return RecommendationResult
  </action>
  <verify>
File created with exports matching IRecommendationAlgorithm interface
Passes TypeScript compilation: npx tsc --noEmit
Follows pattern structure from type-twins.ts
  </verify>
  <done>
Genre Recommendations algorithm implemented: uses user's dominant genres to find highly-rated movies in those genres from similar users
</done>
</task>

<task type="auto">
  <name>Export new algorithms from recommendation-algorithms.ts</name>
  <files>src/lib/recommendation-algorithms.ts</files>
  <action>
Update src/lib/recommendation-algorithms.ts:

1. Add imports for genreTwins and genreRecommendations
2. Add them to recommendationAlgorithms array (as patterns 5 and 6)
3. Export both algorithms
4. Update comment documenting patterns 1-6
  </action>
  <verify>
npm run lint passes
All algorithms properly exported and typed
  </verify>
  <done>
Algorithms exported and available for recommendation pipeline
</done>
</task>

</tasks>

<verification>
- TypeScript compilation passes: npx tsc --noEmit
- Linting passes: npm run lint
- Both algorithms implement IRecommendationAlgorithm interface correctly
- Algorithms follow same architecture as Phase 11 patterns
</verification>

<success_criteria>
- Genre Twins algorithm finds users with similar genre preferences (cosine similarity >= 0.6)
- Genre Recommendations algorithm uses user's dominant genres for recommendations
- Both use normalizeScores() for 0-100 scale
- Both apply 7-day cooldown filtering
- Cold start handled (returns empty, orchestration uses fallback)
- Metrics logged properly
</success_criteria>

<output>
After completion, create .planning/phases/12-advanced-recommendation-patterns/12-01-SUMMARY.md
</output>
