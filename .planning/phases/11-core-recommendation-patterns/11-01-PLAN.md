---
phase: 11-core-recommendation-patterns
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/recommendation-algorithms/types.ts
  - src/lib/recommendation-algorithms/interface.ts
  - src/lib/recommendation-algorithms/taste-match.ts
  - src/lib/recommendation-algorithms/want-overlap.ts
  - src/lib/recommendation-algorithms.ts
  - src/app/api/recommendations/patterns/route.ts
  - src/lib/recommendation-algorithms/__tests__/taste-match.test.ts
  - src/lib/recommendation-algorithms/__tests__/want-overlap.test.ts
autonomous: true
requirements: []

must_haves:
  truths:
    - "User can receive Taste Match recommendations showing movies similar users watched"
    - "User can receive Want-to-Watch Overlap recommendations showing movies similar users want"
    - "All recommendations have normalized scores (0-100)"
    - "Recommendations respect 7-day cooldown from recommendationLog"
    - "All recommendations are logged with algorithm name"
    - "Cold start users (< 10 watched) get TMDB trending fallback"
  artifacts:
    - path: "src/lib/recommendation-algorithms/interface.ts"
      provides: "Common algorithm interface IRecommendationAlgorithm"
      min_lines: 10
    - path: "src/lib/recommendation-algorithms/types.ts"
      provides: "Shared types: RecommendationContext, RecommendationSession, RecommendationResult"
      min_lines: 25
    - path: "src/lib/recommendation-algorithms/taste-match.ts"
      provides: "Pattern 1: Taste Match implementation"
      min_lines: 50
    - path: "src/lib/recommendation-algorithms/want-overlap.ts"
      provides: "Pattern 2: Want-to-Watch Overlap implementation"
      min_lines: 50
    - path: "src/lib/recommendation-algorithms.ts"
      provides: "Main entry point exporting all algorithms"
      min_lines: 10
    - path: "src/app/api/recommendations/patterns/route.ts"
      provides: "API endpoint combining algorithms, returning top 12"
      min_lines: 80
    - path: "src/lib/recommendation-algorithms/__tests__/taste-match.test.ts"
      provides: "Unit tests for Taste Match with mocked dependencies"
      min_lines: 40
    - path: "src/lib/recommendation-algorithms/__tests__/want-overlap.test.ts"
      provides: "Unit tests for Want Overlap with mocked dependencies"
      min_lines: 40
  key_links:
    - from: "src/app/api/recommendations/patterns/route.ts"
      to: "src/lib/recommendation-algorithms.ts"
      via: "import { recommendationAlgorithms } from '@/lib/recommendation-algorithms'"
      pattern: "import.*recommendationAlgorithms"
    - from: "src/lib/recommendation-algorithms/taste-match.ts"
      to: "src/lib/taste-map/similarity.ts"
      via: "calculateTasteMapSimilarity function"
      pattern: "calculateTasteMapSimilarity"
    - from: "src/lib/recommendation-algorithms/taste-match.ts"
      to: "src/lib/taste-map/redis.ts"
      via: "getCachedSimilarUsers or similar Redis functions"
      pattern: "getCachedSimilarUsers|setCachedSimilarUsers"
    - from: "src/lib/recommendation-algorithms/want-overlap.ts"
      to: "prisma.watchList"
      via: "findMany queries filtering status='want'"
      pattern: "prisma\\.watchList\\.findMany"
    - from: "src/app/api/recommendations/patterns/route.ts"
      to: "prisma.recommendationLog"
      via: "create log entry with algorithm field"
      pattern: "prisma\\.recommendationLog\\.create"
---

<objective>
Implement Taste Match and Want-to-Watch Overlap recommendation patterns with API endpoint

Purpose: Create two foundational recommendation patterns that leverage Phase 10 similarity infrastructure to deliver personalized movie suggestions based on similar users' behavior.

Output: Two working pattern algorithms integrated into a new API endpoint at `/api/recommendations/patterns` that returns normalized, cooldown-filtered recommendations.
</objective>

<execution_context>
@C:/Users/n0rds/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/n0rds/.config/opencode/get-shit-done/templates/summary.md

@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/10-taste-map-infrastructure/10-02-SUMMARY.md
@.planning/phases/11-core-recommendation-patterns/11-RESEARCH.md
</execution_context>

<context>
# Phase 11: Core Recommendation Patterns

**Dependencies:** Phase 10 Taste Map infrastructure complete with similarity functions in `src/lib/taste-map/similarity.ts` and Redis caching in `src/lib/taste-map/redis.ts`.

**Architecture:** Create modular recommendation-algorithms library with common interface. Each pattern implements `IRecommendationAlgorithm` with `execute()` returning normalized 0-100 scores. Use existing lib/taste-map/similarity for user comparisons. Use Upstash Redis for caching with 24h TTL. Integrate with existing RecommendationLog table for ML feedback loop.

**Cold Start:** For users with < 10 watched movies, fallback to TMDB trending (lib/tmdb.ts) instead of patterns.

**Standards:** Use logger from '@/lib/logger', prisma singleton from '@/lib/prisma', date-fns for dates, enforce cooldown via recommendationLog (7 days).

**Testing:** Write unit tests mocking Prisma and Redis. Use vi.fn() for similarity functions to isolate pattern logic.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared types and interface</name>
  <files>
    src/lib/recommendation-algorithms/types.ts
    src/lib/recommendation-algorithms/interface.ts
  </files>
  <action>
    Create two files defining the common recommendation algorithm infrastructure:

    1. `types.ts`:
    - Define `RecommendationContext` interface (source, position, candidatesCount, userStatus, filtersChanged)
    - Define `RecommendationSession` interface (sessionId, startTime, previousRecommendations Set, temporalContext, mlFeatures)
    - Define `RecommendationResult` interface (array of { tmdbId, mediaType, title, score: number 0-100, algorithm: string, sources?: string[] }, plus metrics: { candidatesPoolSize, afterFilters, avgScore })
    - Define `RecommendationSession` with TemporalContext and MLFeatures from '@/lib/recommendation-types' (reuse existing types)

    2. `interface.ts`:
    - Define `IRecommendationAlgorithm` interface with fields: name: string, minUserHistory: number, execute(userId: string, context: RecommendationContext, sessionData: RecommendationSession): Promise<RecommendationResult>
    - Export all types and interface

    Use explicit types, no `any`. Follow project conventions: camelCase for variables, PascalCase for interfaces. Import existing types from '@/lib/recommendation-types' to maintain consistency.
  </action>
  <verify>
    TypeScript compiles without errors: `npx tsc --noEmit` shows no type errors in these files. Both files export expected types and interface.
  </verify>
  <done>
    types.ts and interface.ts exist with complete type definitions matching existing RecommendationContext and RecommendationSession from lib/recommendation-types. IRecommendationAlgorithm interface ready for implementation by pattern modules.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Taste Match pattern (Pattern 1)</name>
  <files>
    src/lib/recommendation-algorithms/taste-match.ts
  </files>
  <action>
    Implement Taste Match algorithm in `taste-match.ts`:

    1. Import required dependencies:
    - `{ IRecommendationAlgorithm, RecommendationResult, RecommendationContext, RecommendationSession }` from './interface'
    - `{ prisma }` from '@/lib/prisma'
    - `{ calculateTasteMapSimilarity, getCachedSimilarUsers, setCachedSimilarUsers }` from '@/lib/taste-map/similarity' and '@/lib/taste-map/redis'
    - `{ logger }` from '@/lib/logger'
    - `{ min }` from 'date-fns' (for cooldown calculations)

    2. Implement class/function conforming to IRecommendationAlgorithm:
    - `name: 'taste_match'`
    - `minUserHistory: 10` (skip if user watched < 10)
    - `execute()` method:

    Algorithm steps:
    a) Get user's watched movie count. If < 10, return empty result (caller handles cold start).
    b) Load user's TasteMap from Redis (Phase 10 storage). If missing, compute from watchList (fallback).
    c) Get similar users: call `calculateTasteMapSimilarity` for all users or use cached similar users list from Redis with 24h TTL. Filter similarity > 0.7 threshold.
    d) For each similar user (limit to top 20), fetch their top 10 watched movies (prisma.watchList with status='watched', ordered by userRating desc, limit 10).
    e) Build candidate pool: for each candidate movie, calculate score = (similarity * 0.5) + (userRating * 0.3) + (cooccurrenceWeight * 0.2). Cooccurrence = count of similar users who watched this movie.
    f) Apply 7-day cooldown: fetch recent recommendations from prisma.recommendationLog (last 7 days) and exclude those tmdbId+mediaType.
    g) Normalize all scores to 0-100: find min/max in candidate pool, apply normalization formula. If single candidate, score=100.
    h) Sort by score descending, take top 12.
    i) Log to RecommendationLog with algorithm='taste_match_v1' (create logEntry inside execute or let caller handle? Follow research: algorithms return results, caller logs). Design: return results, caller logs.
    j) Return RecommendationResult with recommendations array and metrics.

    Use proper error handling: try/catch, log errors, rethrow or return empty result. Avoid console.log, use logger.
  </action>
  <verify>
    Run `npm run test` with mocked dependencies. Taste Match returns normalized scores (0-100), excludes cooldown items, respects minUserHistory threshold. Mock Redis cache hit/miss scenarios. Verify score weights sum correctly and similarity threshold > 0.7 filters properly.
  </verify>
  <done>
    taste-match.ts implements IRecommendationAlgorithm correctly, uses Phase 10 similarity functions, applies cooldown, normalizes scores, returns top 12 with metrics. Ready for integration.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement Want-to-Watch Overlap pattern (Pattern 2)</name>
  <files>
    src/lib/recommendation-algorithms/want-overlap.ts
  </files>
  <action>
    Implement Want-to-Watch Overlap algorithm in `want-overlap.ts`:

    1. Import dependencies:
    - `{ IRecommendationAlgorithm, RecommendationResult, RecommendationContext, RecommendationSession }` from './interface'
    - `{ prisma }` from '@/lib/prisma'
    - `{ calculateTasteMapSimilarity, getCachedSimilarUsers }` from '@/lib/taste-map/similarity'
    - `{ logger }` from '@/lib/logger'

    2. Algorithm parameters:
    - `name: 'want_overlap'`
    - `minUserHistory: 5` (lower threshold for users with smaller watch lists)

    3. `execute()` steps:

    a) Get user's watched movies and genre preferences (from watchList status='watched', aggregate genre distribution).
    b) Get similar users: use calculateTasteMapSimilarity with threshold > 0.6 (can be configurable). Get top 15 similar users.
    c) Query "want to watch" items from these similar users: `prisma.watchList.findMany` where userId in similarUserIds, status='want', mediaType in ['movie','tv','anime','cartoon'], addedAt within last 30 days (recent wants). Use distinct on tmdbId+mediaType to avoid duplicates across users.
    d) For each want candidate, calculate score:
       - similarity weight 0.4 (average similarity of users who want this)
       - want frequency 0.4 (count of similar users who added this / total similar users)
       - genre match 0.2 (compare candidate genres to user's preferred genres)
    e) Filter out movies user already watched or already in their want list (exists in watchList for this user).
    f) Apply 7-day cooldown filter (exclude from recommendationLog).
    g) Normalize scores to 0-100. Sort desc, take top 12.
    h) Return RecommendationResult with algorithm='want_overlap_v1' and metrics (initial candidates, after filters, avgScore).

    Notes: Use `distinct` to de-duplicate. Use `addedAt` filter to focus on active wants. Genre match: fetch TMDB details for candidate to get genres, compare to user's top 3 preferred genres (from watch history). If genre data unavailable, skip that component.
  </action>
  <verify>
    Unit tests verify: wants from multiple similar users are deduplicated, cooldown applied, normalization works (scores 0-100), minUserHistory=5 respected. Mock prisma to return specific watchList and similarity data. Test genre matching logic with mock genre arrays.
  </verify>
  <done>
    want-overlap.ts implements IRecommendationAlgorithm, uses similarity functions, applies filters and cooldown, normalizes scores. Ready for integration.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create main entry point and API endpoint</name>
  <files>
    src/lib/recommendation-algorithms.ts
    src/app/api/recommendations/patterns/route.ts
  </files>
  <action>
    Create two integration files:

    1. `src/lib/recommendation-algorithms.ts`:
       - Import pattern implementations that exist in this plan:
         - import { tasteMatch } from './recommendation-algorithms/taste-match'
         - import { wantOverlap } from './recommendation-algorithms/want-overlap'
       - Export as array (will be updated by Plan 11-02):
         - export const recommendationAlgorithms = [tasteMatch, wantOverlap]
       - Export individual algorithms for testing

    2. `src/app/api/recommendations/patterns/route.ts`:
       - Create GET endpoint with authentication via getServerSession
       - Check user's watched movie count from prisma.watchList (status='watched')
       - Cold start detection: if count < 10, return TMDB trending/popular fallback
       - If count >= 10:
         a) Get session data (temporalContext, mlFeatures)
         b) Loop through recommendationAlgorithms array
         c) Call each algorithm's execute() method
         d) Collect all results into unified pool
         e) Deduplicate by tmdbId+mediaType (keep highest score)
         f) Apply final 7-day cooldown filter from recommendationLog
         g) Sort by score descending, take top 12
       - Log each recommendation to prisma.recommendationLog with algorithm field
       - Return JSON: { success: true, recommendations: [...] }
       
       Use rate limiting, logger for errors, proper error handling. Follow existing /api/recommendations/random pattern for fallback.
  </action>
  <verify>
    TypeScript compiles: `npx tsc --noEmit` passes
    API test: `curl -H "Cookie: next-auth.session-token=..." http://localhost:3000/api/recommendations/patterns` returns JSON with recommendations array (or fallback)
  </verify>
  <done>
    recommendation-algorithms.ts exports all 4 algorithms, API endpoint combines results, handles cold start, logs to recommendationLog, returns top 12 normalized recommendations
  </done>
</task>

</tasks>

<verification>
**Phase 11 Plan 01 Verification:**

Execute the following after plan completion:

1. **Type check**: `npx tsc --noEmit` - should pass with no errors
2. **Tests**: `npm run test:ci` - all unit tests for taste-match and want-overlap should pass
3. **API test**: `curl -H "Cookie: next-auth.session-token=VALID_TOKEN" http://localhost:3000/api/recommendations/patterns` returns JSON with `success: true` or fallback message
4. **Integration check**: API endpoint imports `recommendationAlgorithms` and calls both execute() methods, merges results by score, deduplicates, returns top 12
5. **Logging verification**: RecommendationLog entries have algorithm field set to 'taste_match_v1' or 'want_overlap_v1'
6. **Cold start**: For user with < 10 watched, endpoint returns TMDB popular fallback (use 'random' fallback logic from existing /api/recommendations/random)
7. **Cooldown**: Recent recommendations (last 7 days) are excluded from results
8. **Score bounds**: All recommendation scores in response are 0-100 integers or floats

**Manual verification steps:**
- Authenticate as test user, call endpoint, verify JSON structure has `recommendations` array with up to 12 items
- Check that each recommendation has `tmdbId`, `mediaType`, `title`, `score`, `algorithm`
- Verify no duplicate tmdbId+mediaType combos in response
- Check logs show algorithm names correctly
</verification>

<success_criteria>
**Plan 11-01 Success Criteria:**

- ✅ Interface and types defined and used by both pattern implementations
- ✅ Taste Match pattern implemented: returns recommendations based on similar users' watched lists, uses similarity > 0.7, applies cooldown, normalizes scores
- ✅ Want-to-Watch Overlap pattern implemented: returns recommendations based on similar users' want lists, deduplicates, filters user's existing items, normalizes scores
- ✅ Main entry point `recommendation-algorithms.ts` exports both algorithms as named exports and default combined
- ✅ API endpoint `/api/recommendations/patterns` created: authenticates user, determines cold start vs pattern-based, combines algorithm results, returns top 12 normalized recommendations
- ✅ Unit tests cover core logic: score calculation, filtering, cooldown, normalization
- ✅ All TypeScript compiles, lint passes `npm run lint`
- ✅ Recommendations are logged to RecommendationLog with correct algorithm field
- ✅ No console.log remain, all logging uses logger

**Out of scope for this plan:** Drop Patterns and Type Twins (handled in 11-02). Advanced mixing/weighting of algorithms (handled in Phase 13). UI integration (Phase 14).
</success_criteria>

<output>
After completion, create `.planning/phases/11-core-recommendation-patterns/11-01-SUMMARY.md` documenting:
- Files created/modified with line counts
- Architecture decisions (interface design, score normalization approach, cooldown implementation)
- Algorithm weights used and rationale
- Integration approach with API endpoint
- Test coverage summary
- Issues encountered and resolutions
- User setup: None (internal implementation only)
</output>
