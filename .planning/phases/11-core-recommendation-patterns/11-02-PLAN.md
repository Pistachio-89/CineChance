---
phase: 11-core-recommendation-patterns
plan: "02"
type: execute
wave: 2
depends_on: ["01"]
files_modified:
  - src/lib/recommendation-algorithms/drop-patterns.ts
  - src/lib/recommendation-algorithms/type-twins.ts
  - src/lib/recommendation-algorithms.ts
  - src/lib/recommendation-algorithms/__tests__/drop-patterns.test.ts
  - src/lib/recommendation-algorithms/__tests__/type-twins.test.ts
autonomous: true
requirements: []

must_haves:
  truths:
    - "User receives Drop Patterns recommendations avoiding movies similar users dropped"
    - "User receives Type Twins recommendations based on content type preference matching"
    - "All recommendations have normalized scores (0-100)"
    - "Drop penalty logic reduces but does not eliminate candidates entirely"
    - "Type Twins correctly identifies dominant content type and matches accordingly"
    - "Recommendations integrate with existing API endpoint and logging"
  artifacts:
    - path: "src/lib/recommendation-algorithms/drop-patterns.ts"
      provides: "Pattern 3: Drop Patterns implementation"
      min_lines: 40
    - path: "src/lib/recommendation-algorithms/type-twins.ts"
      provides: "Pattern 4: Type Twins implementation"
      min_lines: 50
    - path: "src/lib/recommendation-algorithms/__tests__/drop-patterns.test.ts"
      provides: "Unit tests for Drop Patterns with mocked dependencies"
      min_lines: 30
    - path: "src/lib/recommendation-algorithms/__tests__/type-twins.test.ts"
      provides: "Unit tests for Type Twins with mocked dependencies"
      min_lines: 40
  key_links:
    - from: "src/lib/recommendation-algorithms/drop-patterns.ts"
      to: "prisma.watchList"
      via: "findMany queries filtering status='dropped'"
      pattern: "prisma\\.watchList\\.findMany.*dropped"
    - from: "src/lib/recommendation-algorithms/type-twins.ts"
      to: "user watch history type distribution"
      via: "aggregation by mediaType to calculate percentages"
      pattern: "mediaType.*count|groupBy.*mediaType"
    - from: "src/lib/recommendation-algorithms.ts"
      to: "drop-patterns.ts and type-twins.ts"
      via: "default export combining all four algorithms"
      pattern: "export.*from './drop-patterns'|export.*from './type-twins'"
    - from: "src/app/api/recommendations/patterns/route.ts"
      to: "all four algorithms"
      via: "loop through recommendationAlgorithms array"
      pattern: "recommendationAlgorithms\\.forEach|for.*of.*recommendationAlgorithms"
---

<objective>
Implement Drop Patterns and Type Twins recommendation patterns

Purpose: Complete the four core recommendation patterns by adding avoidance logic (Drop Patterns) and content type matching (Type Twins) to provide diversified and type-aware recommendations.

Output: Two additional pattern algorithms integrated with existing interface and API endpoint, all four patterns working together.
</objective>

<execution_context>
@C:/Users/n0rds/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/n0rds/.config/opencode/get-shit-done/templates/summary.md

@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/10-taste-map-infrastructure/10-02-SUMMARY.md
@.planning/phases/11-core-recommendation-patterns/11-01-PLAN.md (if exists, else will be created concurrently)
@.planning/phases/11-core-recommendation-patterns/11-RESEARCH.md
</execution_context>

<context>
# Phase 11 Patterns 3-4: Drop Patterns and Type Twins

**Dependencies:** Phase 10 complete, similarity functions available. Interface and types from 11-01 will exist (this plan runs parallel wave 1, so we reference them as if they exist; if 11-01 hasn't finished yet, implementation is straightforward anyway). API endpoint from 11-01 will import these new patterns for integration.

**Pattern 3 - Drop Patterns:** Avoid recommending movies that similar users dropped. Uses negative feedback to prevent frustrating recommendations.

**Pattern 4 - Type Twins:** Match users by content type distribution (movies vs TV vs anime vs cartoons). Prioritize user's preferred types.

**Implementation notes:**
- Use IRecommendationAlgorithm interface from 11-01
- Use prisma singleton from '@/lib/prisma'
- Use logger from '@/lib/logger'
- Apply 7-day cooldown from recommendationLog
- Normalize scores to 0-100
- Return RecommendationResult with metrics

**Testing:** Unit tests with mocked Prisma. Test penalty calculations for Drop Patterns, type percentage calculations for Type Twins.

**Integration:** API endpoint from Plan 11-01 imports recommendationAlgorithms array. Plan 11-02 Task 3 updates this file to include all 4 algorithms.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Drop Patterns (Pattern 3)</name>
  <files>
    src/lib/recommendation-algorithms/drop-patterns.ts
  </files>
  <action>
    Create Drop Patterns algorithm in `drop-patterns.ts`:

    1. Import dependencies:
    - `{ IRecommendationAlgorithm, RecommendationResult, RecommendationContext, RecommendationSession }` from './interface'
    - `{ prisma }` from '@/lib/prisma'
    - `{ calculateTasteMapSimilarity }` from '@/lib/taste-map/similarity'
    - `{ logger }` from '@/lib/logger'

    2. Set parameters:
    - `name: 'drop_patterns'`
    - `minUserHistory: 8`

    3. `execute()` algorithm:

    a) Get user's dropped movies and their genres from watchList with status='dropped'. Build a set of dropped tmdbId+mediaType and genre profile (which genres user frequently drops).
    b) Find similar users using similarity > 0.65 threshold (slightly lower than taste-match).
    c) Get dropped movies from similar users: query watchList where userId in similarUserIds and status='dropped' within last 90 days (recent drops). Build frequency map: how many similar users dropped each movie.
    d) Build candidate pool from user's own watched/want lists but NOT in their dropped set. These are movies user might be interested in but similar users dropped.
    e) For each candidate, calculate drop penalty:
       - dropFreq = count of similar users who dropped this movie
       - penalty = min(dropFreq / totalSimilarUsers * 0.7, 0.7) (max 70% penalty)
       - adjustedScore = baseScore * (1 - penalty)
       Base score can be user's preference rating from watchList or a neutral 0.5 if not in their list.
    f) Apply 7-day cooldown filter.
    g) Normalize adjusted scores to 0-100. Sort desc, take top 12.
    h) Return RecommendationResult with algorithm='drop_patterns_v1' and metrics.

    Note: This pattern is defensive - it reduces likelihood of showing movies that caused similar users to abandon. Should be combined with other patterns in ensemble, hence returning fewer candidates or lower weights.
  </action>
  <verify>
    Unit tests verify: drop penalty calculation (0.7 max), cooldown applied, candidates are from user's own lists not dropped, similarity threshold 0.65, normalization produces 0-100 scores. Mock prisma to provide drop data for similar users and verify penalty applied correctly.
  </verify>
  <done>
    drop-patterns.ts implements IRecommendationAlgorithm correctly. Uses similarity from Phase 10, applies drop penalty, respects cooldown, returns normalized results. Ready for integration.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Type Twins (Pattern 4)</name>
  <files>
    src/lib/recommendation-algorithms/type-twins.ts
  </files>
  <action>
    Create Type Twins algorithm in `type-twins.ts`:

    1. Import dependencies:
    - `{ IRecommendationAlgorithm, RecommendationResult, RecommendationContext, RecommendationSession }` from './interface'
    - `{ prisma }` from '@/lib/prisma'
    - `{ logger }` from '@/lib/logger'

    2. Parameters:
    - `name: 'type_twins'`
    - `minUserHistory: 3` (can work with small history)

    3. `execute()` algorithm:

    a) Calculate user's content type distribution:
       Query prisma.watchList for user's watched items (status='watched'), group by mediaType, count. Calculate percentages: movie%, tv%, anime%, cartoon%. If total < 3, still proceed (lowest threshold).
    b) Determine dominant type: the type with highest percentage. If dominant type is >= 50%, we have strong preference. If not, user is type-diverse.
    c) Find type twins: query all users (or sample) and calculate their type distributions from their watchList. Compute Jaccard-like similarity on type vectors:
       similarity = 1 - (sum abs(userTypePct - otherTypePct) / 2). Range 0-1.
       Filter users with similarity >= 0.7 for strong type match.
    d) For each type twin (limit top 10), get their highly-rated watched movies (rating >= 7) that user hasn't watched. Prefer movies of user's dominant type if user has strong preference.
    e) Score candidates:
       - type similarity weight: 0.5
       - twin's rating weight: 0.3
       - user's estimated preference (if candidate type matches user's dominant type, add 0.2)
    f) Apply 7-day cooldown.
    g) Normalize to 0-100, sort desc, top 12.
    h) Return RecommendationResult with algorithm='type_twins_v1' and metrics.

    Implementation details:
    - Use Prisma groupBy for efficiency: `prisma.watchList.groupBy({ by: 'mediaType', where: { userId }, _count: true })`
    - For finding type twins, may need to iterate over recent users to avoid N^2 all-users calculation. Use sampling: get 100 recent active users, compute their distributions, compare.
    - Cache user's type distribution in Redis with 24h TTL? Optional optimization.
  </action>
  <verify>
    Tests verify: type distribution calculation correct for various mediaType mixes, type twin similarity calculation accurate (Jaccard-like), cooldown applied, normalization works, minUserHistory=3 respected. Mock prisma.groupBy and test with mixed-type users.
  </verify>
  <done>
    type-twins.ts implements IRecommendationAlgorithm, calculates user type profile, finds type-matched users, scores candidates with type weighting, applies filters and normalization. Ready for integration.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update entry point to include all 4 algorithms</name>
  <files>
    src/lib/recommendation-algorithms.ts
  </files>
  <action>
    Update `src/lib/recommendation-algorithms.ts` to include all 4 algorithms:

    1. Add imports for the new patterns:
       - import { dropPatterns } from './recommendation-algorithms/drop-patterns'
       - import { typeTwins } from './recommendation-algorithms/type-twins'

    2. Update the export array to include all 4:
       - export const recommendationAlgorithms = [tasteMatch, wantOverlap, dropPatterns, typeTwins]

    This ensures the API endpoint receives all 4 algorithms when it imports recommendationAlgorithms.
  </action>
  <verify>
    TypeScript compiles: `npx tsc --noEmit` passes
    Verify recommendation-algorithms.ts exports array with 4 algorithms
  </verify>
  <done>
    recommendation-algorithms.ts now exports all 4 algorithms, API endpoint can use full ensemble
  </done>
</task>

</tasks>

<verification>
**Phase 11 Plan 02 Verification:**

Execute after plan completion:

1. **Type check**: `npx tsc --noEmit` - no errors in new files
2. **Tests**: `npm run test:ci` - all tests for drop-patterns and type-twins pass
3. **Integration**: API endpoint `/api/recommendations/patterns` returns results combining all four algorithms (taste_match, want_overlap, drop_patterns, type_twins)
4. **Deduplication**: Combined results have no duplicate tmdbId+mediaType
5. **Score normalization verify**: All scores in 0-100 range across all algorithms
6. **Cooldown verify**: Recent recommendations excluded by all patterns
7. **Logging verify**: RecommendationLog entries show correct algorithm field
8. **Performance**: Pattern execution completes within reasonable time (< 2s total) using mocked data; actual production query optimization handled by Phase 10 Redis caching

**Manual checks:**
- Call endpoint with authenticated user, observe JSON response includes `recommendations` array with items from all four algorithms (check `algorithm` field diversity)
- Check that drop_patterns results are present but may have lower scores due to penalties
- Check that type_twins results match user's dominant content type preference
- Verify cold start fallback still works if user has insufficient history
</verification>

<success_criteria>
**Plan 11-02 Success Criteria:**

- ✅ Drop Patterns implemented: returns recommendations with drop penalties applied, reduces likelihood of showing content similar users dropped
- ✅ Type Twins implemented: calculates user type distribution, finds type-similar users, weights candidates by type match
- ✅ Both implement IRecommendationAlgorithm interface
- ✅ Both apply 7-day cooldown and score normalization (0-100)
- ✅ Unit tests cover core logic for both patterns
- ✅ TypeScript compiles without errors
- ✅ All four patterns (11-01 + 11-02) integrated via recommendation-algorithms.ts and available to API endpoint
- ✅ No console.log, uses logger
- ✅ Lint passes: `npm run lint`

**Out of scope:** API endpoint already created in 11-01, no changes needed. UI integration in Phase 14. Weight tuning and A/B testing in Phase 15.
</success_criteria>

<output>
After completion, create `.planning/phases/11-core-recommendation-patterns/11-02-SUMMARY.md` documenting:
- Files created with line counts
- Drop penalty strategy and chosen parameters (0.7 max penalty, 90-day drop window, similarity threshold 0.65)
- Type Twins type calculation method (percentages, similarity metric)
- Integration notes: how these patterns plug into existing API
- Test coverage summary
- Performance considerations (sampling for type twin discovery)
- Issues encountered and resolutions
- User setup: None
</output>
